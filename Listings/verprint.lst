C51 COMPILER V9.59.0.0   VERPRINT                                                          10/29/2021 14:58:47 PAGE 1   


C51 COMPILER V9.59.0.0, COMPILATION OF MODULE VERPRINT
OBJECT MODULE PLACED IN .\Objects\verprint.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE verprint.c LARGE OPTIMIZE(8,SPEED) BROWSE INCDIR(..\vrfcdor_impresora) D
                    -EBUG OBJECTEXTEND PRINT(.\Listings\verprint.lst) TABS(2) OBJECT(.\Objects\verprint.obj)

line level    source

   1          #include <verprint.h>
   2          #include <string.h>
   3          #include <reg51.h>
   4          /*funciones prototipo externas */
   5          
   6          extern void Debug_txt_Tibbo(unsigned char * str);
   7          extern void DebugBufferMF(unsigned char *str,unsigned char num_char,char io);
   8          extern void Debug_chr_Tibbo(unsigned char Dat);
   9          extern void PantallaLCD(unsigned char cod_msg);
  10          extern void send_portERR(unsigned char cod_err);
  11          extern unsigned char  ValidaSensoresPaso(void);
  12          extern void clear_buffer();
  13          extern void Trama_print_cod_barras(unsigned char *msj,unsigned char vehiculo);
  14          extern void Cmd_LPR_Salida_print(unsigned char *msj,unsigned char vehiculo);
  15          extern void Block_read_Clock_Hex(unsigned char *datos_clock);
  16          extern unsigned char bcd_hex (unsigned char l_data);
  17          extern void PantallaLCD(unsigned char cod_msg);
  18          extern char lee_clk (unsigned char dir_clk);
  19          extern void Debug_chr_Tibbo32(unsigned long int dato);
  20          extern unsigned char hex_bcd (unsigned char byte);
  21          
  22          /*variables externas*/
  23          extern unsigned char g_cEstadoComSoft;
  24          extern unsigned char g_cEstadoImpresion;
  25          extern unsigned char ValTimeOutCom;
  26          extern unsigned char buffer_ready;
  27          extern idata unsigned char rbuf [];
  28          extern  unsigned char g_cContByteRx;
  29          extern  unsigned char  USE_LPR;
  30          extern unsigned char Timer_wait;
  31          
  32          #define DIRIJASE_CAJA           90
  33          #define RHORA           0x85
  34          #define RMIN            0x83
  35          sbit lock = P1^7;           //Relevo 
  36          /*----------------------------------------------------------------------------
  37          tiempo de delay entre funciones
  38          ------------------------------------------------------------------------------*/
  39          
  40          #define   TIME_CARD         20    //50
  41          #define   TIME_RX           200   //
  42          #define   TIME_PLACA        55
  43          #define   TIME_PULSADOR     3
  44          
  45          /*----------------------------------------------------------------------------
  46          definicion de recepcion serial 
  47          ------------------------------------------------------------------------------*/
  48          
  49          #define  ESPERA_RX          0           //espera el primer cmd de recepcion del verificado 
  50          /*----------------------------------------------------------------------------
  51          Definiciones de sequencias de lectura de ticket 
  52          ------------------------------------------------------------------------------*/
  53          
  54          #define SEQ_INICIO            0X00  
C51 COMPILER V9.59.0.0   VERPRINT                                                          10/29/2021 14:58:47 PAGE 2   

  55          #define SEQ_LEECODIGO         0X01
  56          #define SEQ_SEND_SOFT         0X02
  57          #define SEQ_SEND_SOFT_QR      0x03
  58          #define SEQ_CMNCCN_PTO        0X04
  59          #define SEQ_REINTENTO         0X05
  60          /*---------------------------------------------------------------------------------
  61          definiciones de la pantalla
  62          -----------------------------------------------------------------------------------*/
  63          #define INGRESO                 0xFA
  64          #define BIENVENIDO              0XFE
  65          #define AUDIO_IN                0XA0    // RELE 1
  66          #define AUDIO_ENTER             0XA1    // RELE 2
  67          #define GRACIAS                 0XFF
  68          
  69          
  70          #define True                    0x01
  71          #define False                   0x00
  72          /*---------------------------------------------------------------------------------
  73          funcion que debuelve la posicion del inicio del primer caracter de numerico de 0 a 9
  74          -----------------------------------------------------------------------------------*/
  75          unsigned char num_num(unsigned char * p)  
  76          {
  77   1      unsigned char contador=0;
  78   1        while ((*p < 0x30)|| (*p > 0x39))
  79   1        {
  80   2          
  81   2          p++;
  82   2          contador++;
  83   2        }
  84   1        return contador;
  85   1      }   
  86          /*---------------------------------------------------------------------------------
  87          definiciones de la pantalla
  88          -----------------------------------------------------------------------------------*/
  89          unsigned char num_char(unsigned char * p,unsigned char chr) 
  90          {
  91   1      unsigned char contador=0;
  92   1        while (*p !=chr)
  93   1        {
  94   2          
  95   2          p++;
  96   2          contador++;
  97   2        }
  98   1        return contador;
  99   1      } 
 100          /*------------------------------------------------------------------------------------
 101          Solo valida año, mes, y dia
 102          ------------------------------------------------------------------------------------*/
 103          unsigned char check_fechaOut_2(unsigned char *buffer)
 104          {
 105   1        unsigned long int fecha_inicio,fecha_fin;
 106   1        unsigned char datos_clk[6];
 107   1        char temp;
 108   1        
 109   1        
 110   1          Block_read_Clock_Hex(datos_clk);                              /*leo el clock actual*/
 111   1          fecha_inicio =  datos_clk[0] * 365 + datos_clk[1] * 30 + datos_clk[2] ;
 112   1          fecha_fin = *(buffer ) * 365 + *(buffer + 1) * 30  + *(buffer + 2);
 113   1          
 114   1          Debug_txt_Tibbo((unsigned char *) "Fecha inicio: ");
 115   1          Debug_chr_Tibbo32(fecha_inicio);
 116   1          Debug_txt_Tibbo((unsigned char *) "\n");
C51 COMPILER V9.59.0.0   VERPRINT                                                          10/29/2021 14:58:47 PAGE 3   

 117   1        
 118   1          Debug_txt_Tibbo((unsigned char *) "Fecha fin: ");
 119   1          Debug_chr_Tibbo32(fecha_fin);
 120   1          Debug_txt_Tibbo((unsigned char *) "\n");
 121   1          if (fecha_fin == fecha_inicio )           
 122   1          {
 123   2            temp = True;
 124   2          }
 125   1          else
 126   1          {
 127   2            Debug_txt_Tibbo((unsigned char *) "El ticket no es del dia ");
 128   2            temp = False;
 129   2          }
 130   1            
 131   1      
 132   1        
 133   1        return temp;
 134   1      }
 135          unsigned Bloque_Horario(unsigned char  * buffer)
 136          {
 137   1        unsigned char Estado_Horario; 
 138   1        unsigned int HoraNow, Hora_Ticket;
 139   1        
 140   1        /*La hora del momento de  salida del vehiculo*/
 141   1        /*la hora del momento de entrada del vehiculo*/
 142   1      
 143   1        Debug_txt_Tibbo((unsigned char *) "HORA AHORA: ");
 144   1        Debug_chr_Tibbo(lee_clk(RHORA));
 145   1        Debug_chr_Tibbo(lee_clk(RMIN));
 146   1        Debug_txt_Tibbo((unsigned char *) "\n");
 147   1        HoraNow = (lee_clk(RHORA) * 60) + (lee_clk(RMIN) );
 148   1        
 149   1        /* desde la hora en que puede ingresar vehiculo */
 150   1        
 151   1        
 152   1        Debug_txt_Tibbo((unsigned char *) "HORA DEL TICKET: ");
 153   1        
 154   1        
 155   1        
 156   1        Debug_chr_Tibbo(hex_bcd(*(buffer+3)));
 157   1        Debug_chr_Tibbo(hex_bcd(*(buffer+4)));
 158   1        Debug_txt_Tibbo((unsigned char *) "\n");
 159   1        Hora_Ticket = hex_bcd(*(buffer+3))* 60 + hex_bcd(*(buffer+4));
 160   1        if(Hora_Ticket < HoraNow )
 161   1          {
 162   2            Debug_txt_Tibbo((unsigned char *) "DESPUES DEL HORARIO PROGRAMADO\r\n");
 163   2            Estado_Horario = False;
 164   2          
 165   2          }
 166   1          else
 167   1          {
 168   2            Debug_txt_Tibbo((unsigned char *) "EN HORARIO PROGRAMADO\r\n");
 169   2            Estado_Horario = True;
 170   2            
 171   2          }
 172   1          return Estado_Horario;
 173   1      }
 174          /*--------------------------------------------------------------------------------------------------------
             ------------------
 175          procedimiento que lee el codigo de barra o el QR
 176          SEQ_INICIO=00 se detecta la presencia vehicular 
 177          SEQ_QUEST_PRINT=1 si fue  presionado el boton 
C51 COMPILER V9.59.0.0   VERPRINT                                                          10/29/2021 14:58:47 PAGE 4   

 178          ----------------------------------------------------------------------------------------------------------
             ------------------*/
 179          
 180          void Lee_ticket(void)
 181          {
 182   1        static unsigned char paso_una_vez=0;
 183   1        static unsigned char Ticket[10];
 184   1        static unsigned char Ticket_copia[10];
 185   1        unsigned char fecha[11];
 186   1        static unsigned char fecha2[10];
 187   1        unsigned char temp,temp2,vehiculo;
 188   1        unsigned char *tipo_vehiculo;
 189   1        switch (g_cEstadoImpresion)
 190   1        {
 191   2          case SEQ_INICIO:
 192   2          /*detecta el vehiculo en el loop*/
 193   2            
 194   2          if (ValTimeOutCom==1)                                                                 /*tiempo de espera */
 195   2          {
 196   3            lock=0;
 197   3            
 198   3            if (ValidaSensoresPaso()!=0)                                                        /*pregunto q alla presencia vehicular*/
 199   3            {
 200   4              Debug_txt_Tibbo((unsigned char *) "\r\n\Vehiculo en el loop\r\n");                  /* se encuentra un sensor a
             -ctivo*/
 201   4              PantallaLCD(BIENVENIDO);                                                          /*msj acerque el ticket*/
 202   4              if(paso_una_vez==0)
 203   4              {
 204   5              send_portERR(AUDIO_IN);                                                           /*habilito el audio de entrada*/
 205   5              paso_una_vez=1;
 206   5              }                           
 207   4              ValTimeOutCom=TIME_RX;
 208   4              g_cEstadoImpresion=SEQ_LEECODIGO;                                                   /*volvemos a preguntar  */  
 209   4                    
 210   4              
 211   4            
 212   4            }
 213   3            else
 214   3              {
 215   4              Debug_txt_Tibbo((unsigned char *) "Vehiculo no en el loop\r\n\r\n");              /* no hay vehiculo en el lo
             -op*/
 216   4              paso_una_vez=0;                                               
 217   4              ValTimeOutCom=TIME_PULSADOR;
 218   4              g_cEstadoImpresion=SEQ_INICIO;                                                    /*volvemos a preguntar  */  
 219   4                    
 220   4              }
 221   3          }
 222   2          break;
 223   2      /*--------------------------------------------------------------------------------------------------------
             ------------------------------------
 224   2      SEQ_LEECODIGO 
 225   2      lee el dato en el pto serial del codigo qr
 226   2      ----------------------------------------------------------------------------------------------------------
             -------------------------------------*/    
 227   2          case SEQ_LEECODIGO:
 228   2            if ((ValTimeOutCom == 1)||(buffer_ready != 0))
 229   2            {
 230   3              if (buffer_ready == 1)
 231   3              {
 232   4                /*trama con codigo QR*/
 233   4                Debug_txt_Tibbo((unsigned char *) "trama del lector datalogic cod QR");             /*la respuesta es desco
             -nocida*/
C51 COMPILER V9.59.0.0   VERPRINT                                                          10/29/2021 14:58:47 PAGE 5   

 234   4                Debug_txt_Tibbo(rbuf);                                                              /*imprimo la trama recibida*/
 235   4                Debug_txt_Tibbo((unsigned char *) "\r\n");
 236   4                ValTimeOutCom=TIME_CARD;                                            
 237   4                g_cEstadoImpresion=SEQ_SEND_SOFT_QR ;   
 238   4                                                                                                    /* buffer del pto serie (0) inicia a esperar la trama*/
 239   4               
 240   4              }
 241   3              else if (buffer_ready == 2)
 242   3              {
 243   4                /*codigo de barras*/
 244   4                strcpy(Ticket,rbuf);                                                                /*salvo el buffer*/
 245   4                temp=strlen(rbuf);                                                                  /*longitud del buffer*/
 246   4                Ticket[temp-1]=0;
 247   4                if (temp>10)
 248   4                {
 249   5                clear_buffer();
 250   5                PantallaLCD(BIENVENIDO);
 251   5                ValTimeOutCom=TIME_RX;
 252   5                g_cEstadoImpresion=SEQ_LEECODIGO; 
 253   5                break;
 254   5                }
 255   4                /*COD DE BARRAS*/ 
 256   4                Debug_txt_Tibbo((unsigned char *) "trama del lector datalogic cod barras");           /*la respuesta es de
             -sconocida*/
 257   4                Debug_txt_Tibbo(Ticket);                                                                /*imprimo la trama recibida*/
 258   4                Debug_txt_Tibbo((unsigned char *) "\r\n");
 259   4                                                          
 260   4              
 261   4                                                                                        /* buffer del pto serie (0) inicia a esperar la trama*/
 262   4                
 263   4                g_cEstadoImpresion=SEQ_SEND_SOFT  ;   
 264   4              }
 265   3              else
 266   3              {
 267   4                /*respuesta incorrecta limpia buffer lee otra vez*/
 268   4                clear_buffer();
 269   4                paso_una_vez=0;
 270   4                buffer_ready=0;   
 271   4                Debug_txt_Tibbo((unsigned char *) "trama del lector datalogic no esta completa\r\n");             /*la resp
             -uesta es desconocida*/
 272   4                ValTimeOutCom=TIME_PULSADOR;
 273   4                g_cEstadoImpresion=SEQ_INICIO;  
 274   4                }
 275   3                      
 276   3            
 277   3              
 278   3            } 
 279   2          break;
 280   2          case SEQ_SEND_SOFT:
 281   2            
 282   2              /*codigo de barras*/
 283   2              Debug_txt_Tibbo((unsigned char *) "cod barras");  
 284   2              buffer_ready=0; 
 285   2              vehiculo='C';
 286   2              Trama_print_cod_barras(Ticket,vehiculo);
 287   2          
 288   2            if(USE_LPR)
 289   2              {
 290   3              Cmd_LPR_Salida_print(Ticket,vehiculo);                                                /*envio datos a Monitor*/
 291   3              }
 292   2              ValTimeOutCom=TIME_PLACA;
 293   2              g_cEstadoImpresion=SEQ_CMNCCN_PTO ;   
C51 COMPILER V9.59.0.0   VERPRINT                                                          10/29/2021 14:58:47 PAGE 6   

 294   2            
 295   2            
 296   2            break;
 297   2            
 298   2          case  SEQ_SEND_SOFT_QR:
 299   2            /*es un codigo QR*/
 300   2            //  ES = 0;                             /*inactivo pto serie y analizo el dato*/
 301   2          
 302   2          /*se tiene la lectura del codigo QR*/
 303   2            if (ValTimeOutCom==1)
 304   2            {
 305   3          
 306   3              Debug_txt_Tibbo((unsigned char *) "cod QR r\n");
 307   3              /*codigo qr*/
 308   3              buffer_ready=0;                                                     /*limpio el testigo de recepcion de datos serie*/
 309   3              
 310   3              temp=num_num(rbuf);                                                 /*funcion que pregunta donde empieza el primer numero del 
             -ticket*/
 311   3              temp2=num_char(rbuf+temp,'>');                                      /*busca un caracter en la trama*/
 312   3              if ((tipo_vehiculo=strstr(rbuf,"Carro"))!= 0)                       /*pregunto el tipo de vehiculo grabado en el 
             -codigo QR*/
 313   3                {
 314   4                vehiculo='C';
 315   4                }
 316   3              else
 317   3                {
 318   4                vehiculo='M';
 319   4                }
 320   3              Debug_txt_Tibbo((unsigned char *) "tipo de vehiculo: ");            /*msj tipo de vehiculo */
 321   3              Debug_chr_Tibbo(vehiculo);                                          /*caracter del tipo de vehiculo*/
 322   3              Debug_txt_Tibbo((unsigned char *) "\n");                            /*final de linea*/
 323   3              
 324   3              Debug_txt_Tibbo((unsigned char *) "longitud de la trama ticket: \n");     /*msj longitud de la trama */
 325   3              Debug_chr_Tibbo(temp);                                              /*numero de inicio del ticket*/
 326   3              Debug_txt_Tibbo((unsigned char *) "\n");                            /*final de linea*/                          
 327   3              Debug_chr_Tibbo(temp2);                                             /*numero de caracteres del ticket*/
 328   3              Debug_txt_Tibbo((unsigned char *) "\n");                            /*final de linea*/
 329   3             
 330   3              Ticket[0]=0;
 331   3              if(temp== 0x0c)                                                     /*la trama debe iniciar en 0x0c*/
 332   3              { 
 333   4                strncpy(Ticket,rbuf+temp,temp2);                                    /*copio el numero de ticket*/
 334   4                Ticket[temp2]=0;                                                    /*finalizo la trama con (0)*/
 335   4                      
 336   4                Debug_txt_Tibbo(Ticket);                                            /*imprimo el numero de ticket*/
 337   4                Debug_txt_Tibbo((unsigned char *) "\n");                            /*final de linea*/
 338   4              /*----------------------------------------------------*/
 339   4              /*buscamos la fecha de salida  en el ticket*/
 340   4                
 341   4                temp=num_char(rbuf+temp,':')+temp;
 342   4                temp2=num_char(rbuf+temp,'>');
 343   4                Debug_txt_Tibbo((unsigned char *) "longitud de la trama fecha: \n");
 344   4                Debug_chr_Tibbo(temp);  
 345   4                Debug_chr_Tibbo(temp2);                                             /*numero de caracteres del ticket*/
 346   4                Debug_txt_Tibbo((unsigned char *) "\n");  
 347   4                strncpy(fecha,rbuf+temp+2,temp2);
 348   4                fecha[temp2-2]=0;
 349   4                /*se pasa de bcd a hex para comparacion*/
 350   4                /*año*/
 351   4                fecha2[0]=bcd_hex((fecha[2]-0x30)<<4 | fecha[3]-0x30);
 352   4                /*mes*/
 353   4                fecha2[1]=bcd_hex((fecha[5]-0x30)<<4 | fecha[6]-0x30);
C51 COMPILER V9.59.0.0   VERPRINT                                                          10/29/2021 14:58:47 PAGE 7   

 354   4                /*dia*/
 355   4                fecha2[2]=bcd_hex((fecha[8]-0x30)<<4 | fecha[9]-0x30);
 356   4                /*horas*/
 357   4                fecha2[3]=bcd_hex((fecha[0x0b]-0x30)<<4 | fecha[0xc]-0x30);
 358   4                /*minutos*/
 359   4                fecha2[4]=bcd_hex((fecha[0x0e]-0x30)<<4 | fecha[0xf]-0x30);
 360   4                /*--------------------------------------------------*/
 361   4                Debug_txt_Tibbo((unsigned char *) "Fecha de salida: ");           /*msj tipo de vehiculo */
 362   4                Debug_txt_Tibbo((unsigned char *)fecha);                                          /*caracter del tipo de vehiculo*/
 363   4                Debug_txt_Tibbo((unsigned char *) "\n");                          /*final de linea*/          
 364   4                
 365   4                if (check_fechaOut_2(fecha2)!= True)
 366   4                {
 367   5                  /*dirijase a caja*/
 368   5                  PantallaLCD(DIRIJASE_CAJA);
 369   5                  g_cEstadoImpresion=SEQ_LEECODIGO;   
 370   5                  break;
 371   5                }
 372   4                if(Bloque_Horario(fecha2) != True)
 373   4                {
 374   5                  /*dirijase a caja*/
 375   5                  PantallaLCD(DIRIJASE_CAJA);
 376   5                  g_cEstadoImpresion=SEQ_LEECODIGO;   
 377   5                  break;
 378   5                }
 379   4                Trama_print_cod_barras(Ticket,vehiculo);                            /*envio la trama al pto paralelo y es enviada a
             -l principal el cual comunica con acces*/
 380   4              
 381   4              
 382   4                if(USE_LPR)
 383   4                {
 384   5                Cmd_LPR_Salida_print(Ticket,vehiculo);                                /*envio datos a Monitor*/
 385   5                }
 386   4              
 387   4              ValTimeOutCom=TIME_PLACA;
 388   4              g_cEstadoImpresion=SEQ_CMNCCN_PTO ; 
 389   4              break;
 390   4            }
 391   3            else
 392   3            {
 393   4                ES = 1;
 394   4                clear_buffer();
 395   4                ValTimeOutCom=TIME_RX;
 396   4                g_cEstadoImpresion=SEQ_LEECODIGO;   
 397   4              
 398   4            }
 399   3          }
 400   2          break;
 401   2          case SEQ_CMNCCN_PTO:
 402   2              
 403   2            
 404   2          if ((tipo_vehiculo=strstr(Ticket_copia,Ticket))== 0)  
 405   2          {
 406   3            lock=1;
 407   3            strcpy(Ticket_copia,Ticket);
 408   3          }
 409   2            
 410   2            if (ValTimeOutCom==1)
 411   2            {
 412   3              lock=0;
 413   3              ES = 1;                                                                             /*habilito pto*/
 414   3              Debug_txt_Tibbo((unsigned char *) "fin de lectura de trama\r\n");                   /*la respuesta es desconoci
C51 COMPILER V9.59.0.0   VERPRINT                                                          10/29/2021 14:58:47 PAGE 8   

             -da*/
 415   3              //PantallaLCD(GRACIAS);
 416   3              ValTimeOutCom=TIME_PULSADOR;
 417   3              clear_buffer();
 418   3              paso_una_vez=0;      
 419   3              g_cEstadoImpresion=SEQ_INICIO;
 420   3            }
 421   2            break;
 422   2          default:
 423   2          g_cEstadoImpresion=SEQ_INICIO;
 424   2          break;
 425   2        
 426   2          case SEQ_REINTENTO:
 427   2            if (ValTimeOutCom==1)
 428   2            {
 429   3              Debug_txt_Tibbo((unsigned char *) "REENVIA TRAMA PTO PARALELO\r\n ");           /*msj tipo de vehiculo */
 430   3              
 431   3              Trama_print_cod_barras(Ticket,vehiculo);  
 432   3              ValTimeOutCom=TIME_PLACA;
 433   3              g_cEstadoImpresion=SEQ_CMNCCN_PTO ; 
 434   3            }
 435   2              break;    
 436   2        }
 437   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1707    ----
   CONSTANT SIZE    =    495    ----
   XDATA SIZE       =     31      41
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
