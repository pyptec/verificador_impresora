C51 COMPILER V9.59.0.0   VERPRINT                                                          10/28/2021 15:39:22 PAGE 1   


C51 COMPILER V9.59.0.0, COMPILATION OF MODULE VERPRINT
OBJECT MODULE PLACED IN .\Objects\verprint.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE verprint.c LARGE OPTIMIZE(8,SPEED) BROWSE INCDIR(..\vrfcdor_impresora) D
                    -EBUG OBJECTEXTEND PRINT(.\Listings\verprint.lst) TABS(2) OBJECT(.\Objects\verprint.obj)

line level    source

   1          #include <verprint.h>
   2          #include <string.h>
   3          #include <reg51.h>
   4          /*funciones prototipo externas */
   5          
   6          extern void Debug_txt_Tibbo(unsigned char * str);
   7          extern void DebugBufferMF(unsigned char *str,unsigned char num_char,char io);
   8          extern void Debug_chr_Tibbo(unsigned char Dat);
   9          extern void PantallaLCD(unsigned char cod_msg);
  10          extern void send_portERR(unsigned char cod_err);
  11          extern unsigned char  ValidaSensoresPaso(void);
  12          extern void clear_buffer();
  13          extern void Trama_print_cod_barras(unsigned char *msj,unsigned char vehiculo);
  14          extern void Cmd_LPR_Salida_print(unsigned char *msj,unsigned char vehiculo);
  15          extern void Block_read_Clock_Hex(unsigned char *datos_clock);
  16          extern unsigned char bcd_hex (unsigned char l_data);
  17          extern void PantallaLCD(unsigned char cod_msg);
  18          extern char lee_clk (unsigned char dir_clk);
  19          
  20          
  21          /*variables externas*/
  22          extern unsigned char g_cEstadoComSoft;
  23          extern unsigned char g_cEstadoImpresion;
  24          extern unsigned char ValTimeOutCom;
  25          extern unsigned char buffer_ready;
  26          extern idata unsigned char rbuf [];
  27          extern  unsigned char g_cContByteRx;
  28          extern  unsigned char  USE_LPR;
  29          extern unsigned char Timer_wait;
  30          
  31          #define DIRIJASE_CAJA           90
  32          #define RHORA           0x85
  33          #define RMIN            0x83
  34          sbit lock = P1^7;           //Relevo 
  35          /*----------------------------------------------------------------------------
  36          tiempo de delay entre funciones
  37          ------------------------------------------------------------------------------*/
  38          
  39          #define   TIME_CARD         20    //50
  40          #define   TIME_RX           200   //
  41          #define   TIME_PLACA        55
  42          #define   TIME_PULSADOR     3
  43          
  44          /*----------------------------------------------------------------------------
  45          definicion de recepcion serial 
  46          ------------------------------------------------------------------------------*/
  47          
  48          #define  ESPERA_RX          0           //espera el primer cmd de recepcion del verificado 
  49          /*----------------------------------------------------------------------------
  50          Definiciones de sequencias de lectura de ticket 
  51          ------------------------------------------------------------------------------*/
  52          
  53          #define SEQ_INICIO            0X00  
  54          #define SEQ_LEECODIGO         0X01
C51 COMPILER V9.59.0.0   VERPRINT                                                          10/28/2021 15:39:22 PAGE 2   

  55          #define SEQ_SEND_SOFT         0X02
  56          #define SEQ_SEND_SOFT_QR      0x03
  57          #define SEQ_CMNCCN_PTO        0X04
  58          #define SEQ_REINTENTO         0X05
  59          /*---------------------------------------------------------------------------------
  60          definiciones de la pantalla
  61          -----------------------------------------------------------------------------------*/
  62          #define INGRESO                 0xFA
  63          #define BIENVENIDO              0XFE
  64          #define AUDIO_IN                0XA0    // RELE 1
  65          #define AUDIO_ENTER             0XA1    // RELE 2
  66          #define GRACIAS                 0XFF
  67          
  68          
  69          #define True                    0x01
  70          #define False                   0x00
  71          /*---------------------------------------------------------------------------------
  72          funcion que debuelve la posicion del inicio del primer caracter de numerico de 0 a 9
  73          -----------------------------------------------------------------------------------*/
  74          unsigned char num_num(unsigned char * p)  
  75          {
  76   1      unsigned char contador=0;
  77   1        while ((*p < 0x30)|| (*p > 0x39))
  78   1        {
  79   2          
  80   2          p++;
  81   2          contador++;
  82   2        }
  83   1        return contador;
  84   1      }   
  85          /*---------------------------------------------------------------------------------
  86          definiciones de la pantalla
  87          -----------------------------------------------------------------------------------*/
  88          unsigned char num_char(unsigned char * p,unsigned char chr) 
  89          {
  90   1      unsigned char contador=0;
  91   1        while (*p !=chr)
  92   1        {
  93   2          
  94   2          p++;
  95   2          contador++;
  96   2        }
  97   1        return contador;
  98   1      } 
  99          /*------------------------------------------------------------------------------------
 100          Solo valida año, mes, y dia
 101          ------------------------------------------------------------------------------------*/
 102          unsigned char check_fechaOut_2(unsigned char *buffer)
 103          {
 104   1        unsigned long int fecha_inicio,fecha_fin;
 105   1        unsigned char datos_clk[6];
 106   1        char temp;
 107   1        
 108   1        
 109   1          Block_read_Clock_Hex(datos_clk);                              /*leo el clock actual*/
 110   1          fecha_inicio =  datos_clk[0] * 365 + datos_clk[1] * 30 + datos_clk[2] ;
 111   1          fecha_fin = *(buffer ) * 365 + *(buffer + 1) * 30  + *(buffer + 2);
 112   1          
 113   1            
 114   1          if (fecha_fin >= fecha_inicio )           
 115   1          {
 116   2            temp = True;
C51 COMPILER V9.59.0.0   VERPRINT                                                          10/28/2021 15:39:22 PAGE 3   

 117   2          }
 118   1          else
 119   1          {
 120   2            temp = False;
 121   2          }
 122   1            
 123   1      
 124   1        
 125   1        return temp;
 126   1      }
 127          unsigned Bloque_Horario(unsigned char  * buffer)
 128          {
 129   1        unsigned char Estado_Horario; 
 130   1        unsigned int HoraNow, Hora_Ticket;
 131   1        
 132   1        /*la hora del momento de entrada del vehiculo*/
 133   1      
 134   1        Debug_txt_Tibbo((unsigned char *) "HORA AHORA: ");
 135   1        Debug_chr_Tibbo(lee_clk(RHORA));
 136   1        Debug_chr_Tibbo(lee_clk(RMIN));
 137   1        Debug_txt_Tibbo((unsigned char *) "\r\n");
 138   1        HoraNow = (lee_clk(RHORA) * 60) + (lee_clk(RMIN) );
 139   1        
 140   1        /* desde la hora en que puede ingresar vehiculo */
 141   1        
 142   1        
 143   1        Debug_txt_Tibbo((unsigned char *) "HORA PROGRAMADA DESDE: ");
 144   1        Hora_Ticket = *(buffer+3)* 60 + *(buffer+4);
 145   1        if( HoraNow <= Hora_Ticket)
 146   1          {
 147   2            //send_portERR(PRMR_MENSUAL_FUERA_HORARIO);
 148   2            Debug_txt_Tibbo((unsigned char *) "EN HORARIO PROGRAMADO\r\n");
 149   2            Estado_Horario = True;
 150   2          }
 151   1          else
 152   1          {
 153   2            //send_portERR(PRMR_MENSUAL_FUERA_HORARIO);
 154   2            //PantallaLCD(MENSUAL_FUERA_HORARIO);
 155   2            Debug_txt_Tibbo((unsigned char *) "DESPUES DEL HORARIO PROGRAMADO\r\n");
 156   2            Estado_Horario = False;
 157   2          }
 158   1          return Estado_Horario;
 159   1      }
 160          /*--------------------------------------------------------------------------------------------------------
             ------------------
 161          procedimiento que lee el codigo de barra o el QR
 162          SEQ_INICIO=00 se detecta la presencia vehicular 
 163          SEQ_QUEST_PRINT=1 si fue  presionado el boton 
 164          ----------------------------------------------------------------------------------------------------------
             ------------------*/
 165          
 166          void Lee_ticket(void)
 167          {
 168   1        static unsigned char paso_una_vez=0;
 169   1        static unsigned char Ticket[10];
 170   1        unsigned char fecha[11];
 171   1        static unsigned char fecha2[10];
 172   1        unsigned char temp,temp2,vehiculo;
 173   1        unsigned char *tipo_vehiculo;
 174   1        switch (g_cEstadoImpresion)
 175   1        {
 176   2          case SEQ_INICIO:
C51 COMPILER V9.59.0.0   VERPRINT                                                          10/28/2021 15:39:22 PAGE 4   

 177   2          /*detecta el vehiculo en el loop*/
 178   2            
 179   2          if (ValTimeOutCom==1)                                                                 /*tiempo de espera */
 180   2          {
 181   3            lock=0;
 182   3            
 183   3            if (ValidaSensoresPaso()!=0)                                                        /*pregunto q alla presencia vehicular*/
 184   3            {
 185   4              Debug_txt_Tibbo((unsigned char *) "\r\n\Vehiculo en el loop\r\n");                  /* se encuentra un sensor a
             -ctivo*/
 186   4              PantallaLCD(BIENVENIDO);                                                          /*msj acerque el ticket*/
 187   4              if(paso_una_vez==0)
 188   4              {
 189   5              send_portERR(AUDIO_IN);                                                           /*habilito el audio de entrada*/
 190   5              paso_una_vez=1;
 191   5              }                           
 192   4              ValTimeOutCom=TIME_RX;
 193   4              g_cEstadoImpresion=SEQ_LEECODIGO;                                                   /*volvemos a preguntar  */  
 194   4                    
 195   4              
 196   4            
 197   4            }
 198   3            else
 199   3              {
 200   4              Debug_txt_Tibbo((unsigned char *) "Vehiculo no en el loop\r\n\r\n");              /* no hay vehiculo en el lo
             -op*/
 201   4              paso_una_vez=0;                                               
 202   4              ValTimeOutCom=TIME_PULSADOR;
 203   4              g_cEstadoImpresion=SEQ_INICIO;                                                    /*volvemos a preguntar  */  
 204   4                    
 205   4              }
 206   3          }
 207   2          break;
 208   2      /*--------------------------------------------------------------------------------------------------------
             ------------------------------------
 209   2      SEQ_LEECODIGO 
 210   2      lee el dato en el pto serial del codigo qr
 211   2      ----------------------------------------------------------------------------------------------------------
             -------------------------------------*/    
 212   2          case SEQ_LEECODIGO:
 213   2            if ((ValTimeOutCom == 1)||(buffer_ready != 0))
 214   2            {
 215   3              if (buffer_ready == 1)
 216   3              {
 217   4                /*trama con codigo QR*/
 218   4                Debug_txt_Tibbo((unsigned char *) "trama del lector datalogic cod QR");             /*la respuesta es desco
             -nocida*/
 219   4                Debug_txt_Tibbo(rbuf);                                                              /*imprimo la trama recibida*/
 220   4                Debug_txt_Tibbo((unsigned char *) "\r\n");
 221   4                ValTimeOutCom=TIME_CARD;                                            
 222   4                g_cEstadoImpresion=SEQ_SEND_SOFT_QR ;   
 223   4                                                                                                    /* buffer del pto serie (0) inicia a esperar la trama*/
 224   4               
 225   4              }
 226   3              else if (buffer_ready == 2)
 227   3              {
 228   4                /*codigo de barras*/
 229   4                strcpy(Ticket,rbuf);                                                                /*salvo el buffer*/
 230   4                temp=strlen(rbuf);                                                                  /*longitud del buffer*/
 231   4                Ticket[temp-1]=0;
 232   4                if (temp>10)
 233   4                {
C51 COMPILER V9.59.0.0   VERPRINT                                                          10/28/2021 15:39:22 PAGE 5   

 234   5                clear_buffer();
 235   5                PantallaLCD(BIENVENIDO);
 236   5                ValTimeOutCom=TIME_RX;
 237   5                g_cEstadoImpresion=SEQ_LEECODIGO; 
 238   5                break;
 239   5                }
 240   4                /*COD DE BARRAS*/ 
 241   4                Debug_txt_Tibbo((unsigned char *) "trama del lector datalogic cod barras");           /*la respuesta es de
             -sconocida*/
 242   4                Debug_txt_Tibbo(Ticket);                                                                /*imprimo la trama recibida*/
 243   4                Debug_txt_Tibbo((unsigned char *) "\r\n");
 244   4                                                          
 245   4              
 246   4                                                                                        /* buffer del pto serie (0) inicia a esperar la trama*/
 247   4                
 248   4                g_cEstadoImpresion=SEQ_SEND_SOFT  ;   
 249   4              }
 250   3              else
 251   3              {
 252   4                /*respuesta incorrecta limpia buffer lee otra vez*/
 253   4                clear_buffer();
 254   4                paso_una_vez=0;
 255   4                buffer_ready=0;   
 256   4                Debug_txt_Tibbo((unsigned char *) "trama del lector datalogic no esta completa\r\n");             /*la resp
             -uesta es desconocida*/
 257   4                ValTimeOutCom=TIME_PULSADOR;
 258   4                g_cEstadoImpresion=SEQ_INICIO;  
 259   4                }
 260   3                      
 261   3            
 262   3              
 263   3            } 
 264   2          break;
 265   2          case SEQ_SEND_SOFT:
 266   2            
 267   2              /*codigo de barras*/
 268   2              Debug_txt_Tibbo((unsigned char *) "cod barras");  
 269   2              buffer_ready=0; 
 270   2              vehiculo='C';
 271   2              Trama_print_cod_barras(Ticket,vehiculo);
 272   2          
 273   2            if(USE_LPR)
 274   2              {
 275   3              Cmd_LPR_Salida_print(Ticket,vehiculo);                                                /*envio datos a Monitor*/
 276   3              }
 277   2              ValTimeOutCom=TIME_PLACA;
 278   2              g_cEstadoImpresion=SEQ_CMNCCN_PTO ;   
 279   2            
 280   2            
 281   2            break;
 282   2            
 283   2          case  SEQ_SEND_SOFT_QR:
 284   2            /*es un codigo QR*/
 285   2            //  ES = 0;                             /*inactivo pto serie y analizo el dato*/
 286   2            if (ValTimeOutCom==1)
 287   2            {
 288   3          
 289   3              Debug_txt_Tibbo((unsigned char *) "cod QR r\n");
 290   3              /*codigo qr*/
 291   3              buffer_ready=0;                     /*limpio el testigo de recepcion de datos serie*/
 292   3              
 293   3              temp=num_num(rbuf);                 /*funcion que pregunta donde empieza el primer numero del ticket*/
C51 COMPILER V9.59.0.0   VERPRINT                                                          10/28/2021 15:39:22 PAGE 6   

 294   3              temp2=num_char(rbuf+temp,'>');      /*busca un caracter en la trama*/
 295   3              if ((tipo_vehiculo=strstr(rbuf,"Carro"))!= 0) /*pregunto el tipo de vehiculo grabado en el codigo QR*/
 296   3                {
 297   4                vehiculo='C';
 298   4                }
 299   3              else
 300   3                {
 301   4                vehiculo='M';
 302   4                }
 303   3              Debug_txt_Tibbo((unsigned char *) "tipo de vehiculo: ");            /*msj tipo de vehiculo */
 304   3              Debug_chr_Tibbo(vehiculo);                                          /*caracter del tipo de vehiculo*/
 305   3              Debug_txt_Tibbo((unsigned char *) "\r\n");                          /*final de linea*/
 306   3              
 307   3              Debug_txt_Tibbo((unsigned char *) "longitud de la trama: \r\n");    /*msj longitud de la trama */
 308   3              Debug_chr_Tibbo(temp);                                              /*numero de inicio del ticket*/
 309   3              Debug_txt_Tibbo((unsigned char *) "\r\n");                          /*final de linea*/                          
 310   3              Debug_chr_Tibbo(temp2);                                             /*numero de caracteres del ticket*/
 311   3              Debug_txt_Tibbo((unsigned char *) "\r\n");                          /*final de linea*/
 312   3             
 313   3              Ticket[0]=0;
 314   3              if(temp== 0x0c)                                                     /*la trama debe iniciar en 0x0c*/
 315   3              { 
 316   4              strncpy(Ticket,rbuf+temp,temp2);                                    /*copio el numero de ticket*/
 317   4              Ticket[temp2]=0;                                                    /*finalizo la trama con (0)*/
 318   4                      
 319   4              Debug_txt_Tibbo(Ticket);                                            /*imprimo el numero de ticket*/
 320   4              Debug_txt_Tibbo((unsigned char *) "\r\n");                          /*final de linea*/
 321   4              /*----------------------------------------------------*/
 322   4              /*buscamos la fecha de salida  en el ticket*/
 323   4                
 324   4                temp=num_char(rbuf+temp,':')+temp;
 325   4                Debug_chr_Tibbo(temp);  
 326   4                temp2=num_char(rbuf+temp,'>');
 327   4                Debug_chr_Tibbo(temp2);                                             /*numero de caracteres del ticket*/
 328   4                Debug_txt_Tibbo((unsigned char *) "\r\n");  
 329   4                strncpy(fecha,rbuf+temp+2,temp2);
 330   4                fecha[temp2-2]=0;
 331   4                /*año*/
 332   4                fecha2[0]=bcd_hex((fecha[2]-0x30)<<4 | fecha[3]-0x30);
 333   4                /*mes*/
 334   4                fecha2[1]=bcd_hex((fecha[5]-0x30)<<4 | fecha[6]-0x30);
 335   4                /*dia*/
 336   4                fecha2[2]=bcd_hex((fecha[8]-0x30)<<4 | fecha[9]-0x30);
 337   4                /*horas*/
 338   4                fecha2[3]=bcd_hex((fecha[0x0b]-0x30)<<4 | fecha[0xc]-0x30);
 339   4                /*minutos*/
 340   4                fecha2[4]=bcd_hex((fecha[0x0e]-0x30)<<4 | fecha[0xf]-0x30);
 341   4                /*--------------------------------------------------*/
 342   4              Debug_txt_Tibbo((unsigned char *) "Fecha de salida: ");           /*msj tipo de vehiculo */
 343   4              Debug_txt_Tibbo((unsigned char *)fecha);                                          /*caracter del tipo de vehiculo*/
 344   4              Debug_txt_Tibbo((unsigned char *) "\n");                          /*final de linea*/          
 345   4                
 346   4              if (check_fechaOut_2(fecha2)!= True)
 347   4              {
 348   5                /*dirijase a caja*/
 349   5                PantallaLCD(DIRIJASE_CAJA);
 350   5              }
 351   4              if(Bloque_Horario(fecha2) != True)
 352   4              {
 353   5                /*dirijase a caja*/
 354   5                PantallaLCD(DIRIJASE_CAJA);
 355   5              }
C51 COMPILER V9.59.0.0   VERPRINT                                                          10/28/2021 15:39:22 PAGE 7   

 356   4              Trama_print_cod_barras(Ticket,vehiculo);                            /*envio la trama al pto paralelo y es enviada al
             - principal el cual comunica con acces*/
 357   4              
 358   4              
 359   4              if(USE_LPR)
 360   4              {
 361   5              Cmd_LPR_Salida_print(Ticket,vehiculo);                                /*envio datos a Monitor*/
 362   5              }
 363   4              ValTimeOutCom=TIME_PLACA;
 364   4              g_cEstadoImpresion=SEQ_CMNCCN_PTO ; 
 365   4              break;
 366   4              }
 367   3              else
 368   3              {
 369   4                ES = 1;
 370   4                clear_buffer();
 371   4              //  PantallaLCD(BIENVENIDO);
 372   4                //send_portERR(TARJETA_INVALIDA);  
 373   4                ValTimeOutCom=TIME_RX;
 374   4                g_cEstadoImpresion=SEQ_LEECODIGO;   
 375   4              
 376   4              }
 377   3            }
 378   2                break;
 379   2          case SEQ_CMNCCN_PTO:
 380   2            lock=1;
 381   2            if (ValTimeOutCom==1)
 382   2            {
 383   3              lock=0;
 384   3              ES = 1;                                                                             /*habilito pto*/
 385   3              Debug_txt_Tibbo((unsigned char *) "fin de lectura de trama\r\n");                   /*la respuesta es desconoci
             -da*/
 386   3              //PantallaLCD(GRACIAS);
 387   3              ValTimeOutCom=TIME_PULSADOR;
 388   3              clear_buffer();
 389   3              paso_una_vez=0;      
 390   3              g_cEstadoImpresion=SEQ_INICIO;
 391   3            }
 392   2            break;
 393   2          default:
 394   2          g_cEstadoImpresion=SEQ_INICIO;
 395   2          break;
 396   2        
 397   2          case SEQ_REINTENTO:
 398   2            if (ValTimeOutCom==1)
 399   2            {
 400   3              Debug_txt_Tibbo((unsigned char *) "REENVIA TRAMA PTO PARALELO\r\n ");           /*msj tipo de vehiculo */
 401   3              
 402   3              Trama_print_cod_barras(Ticket,vehiculo);  
 403   3              ValTimeOutCom=TIME_PLACA;
 404   3              g_cEstadoImpresion=SEQ_CMNCCN_PTO ; 
 405   3            }
 406   2              break;    
 407   2        }
 408   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1476    ----
   CONSTANT SIZE    =    413    ----
   XDATA SIZE       =     21      41
   PDATA SIZE       =   ----    ----
C51 COMPILER V9.59.0.0   VERPRINT                                                          10/28/2021 15:39:22 PAGE 8   

   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
